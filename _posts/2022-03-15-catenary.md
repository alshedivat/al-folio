---
layout: distill
title: "Catenary objects: putting a wire between two points"
description: "Modelling a hanging physically/geometrically correct chain supported only at its endpoints."
tags: [code, python, godot, gdscript, geometry, physics]
date: 2022-03-15
giscus_comments: true
featured: true
bibliography: 2022-03-15-distill.bib
authors:
  - name: Mathias Baumgartinger
    affiliations:
      name: Vienna, AT
toc:
  - name: TL;DR
  - name: From Sessions to Tokens in Django
  - name: What, Why and How?
  - name: "Implementation Details: Backend"
  - name: "Implementation Details: Frontend"
  - name: Feature-Comparison
---

## A seemingly trivial problem that is non-trivial: catenaries

Because gravitational force is so ubiquitous, we think of an objecting hanging and sagging as intuitive and -- at least I for my part -- trivially solved. Suppose we have two points and a line of given length, how do we model the underlying sagged rope/chain/cable? Mathematically, we call the resulting shape a catenary:

> In physics and geometry, a catenary (US: /ˈkætənɛri/ KAT-ən-err-ee, UK: /kəˈtiːnəri/ kə-TEE-nər-ee) is the curve that an idealized hanging chain or cable assumes under its own weight when supported only at its ends in a uniform gravitational field <d-cite key="Catenary2022"></d-cite>.

This implementation was motivated by power lines in the real world, they never form a straight line between pylons. They sag. This reoccurring behavior is applicable to many objects in real world: overhead-cables for trains, cable cars, fences, even some natural phenomena like heavy wine branches or spider webs.

In the [LandscapeLab](ttps://landscapelab.boku.ac.at/) -- a data driven, generic 3D landscape visualization toolkit -- we abstracted this behavior for reusability as "connected" objects. In this blog we learn how to define:

- the **exact length** of the cable (as a factor over straight-line distance)  
- arbitrary **3D positions** of the two endpoints in the landscape

That combination turns out to be more subtle than just “interpolate some points” or “throw a quadratic at it”. This post walks through how we solved it numerically and how we map the solution back into 3D space.

---

## Why a simple interpolation isn’t enough

If we only cared about a nice looking curve between two points $P_1$ and $P_2$, we could use a Bézier curve, or a spline. But all of these suffer from one big issue:  **You don’t control the physical length of the wire.**

In reality, a cable has a fixed length. If you move the poles further apart or change their relative height, the curve must adapt so that:

- It still connects P₁ and P₂ exactly, **and**
- The **arc length** of the curve is a given value \(L\) (e.g. straight-line distance × some factor).

That constraint leads you directly into the catenary.

---

## From 3D to a simpler 2D view

The actual poles and wires live in 3D world space, but the catenary math is a 2D problem: one horizontal axis and one vertical axis.

So the first step in our `AbstractConnection` implementation is to **project the 3D situation to a 2D one**:

```gdscript
# assume _P1 and _P2 are the 3D endpoints

# make sure P1 has the higher x so the math is consistent
if _P1.x < _P2.x:
    var temp = _P2
    _P2 = _P1
    _P1 = temp

# V1 is the horizontal base for P1
var V1 = Vector3(_P1.x, 0, _P1.z)

# V2 is the 3D vector P1->P2, but flattened into the horizontal plane
var V2 = _P2 - _P1
V2.y = 0

# 2D representation:
var P1_2D = Vector2(0, _P1.y)
var P2_2D = Vector2(V2.length(), _P2.y)
```

Interpretation:

- In 2D, **x** is “distance along the ground” between the two poles.
- **y** is the height of the cable at that x.
- \(P1_{2D} = (0, y_1)\) and \(P2_{2D} = (d, y_2)\) where \(d\) is the ground distance between the poles.

Now we can forget about 3D for a moment and solve a pure 2D catenary problem.

---

## The catenary problem we want to solve

The standard catenary in 2D is

\[
y(x) = a \cosh\left(\frac{x - b}{a}\right) + c
\]

We want to find parameters \(a, b, c\) such that:

1. The curve passes through both endpoints:

   \[
   y(x_1) = y_1,\quad y(x_2) = y_2
   \]

2. The **arc length** between the endpoints equals a given total length \(L\).

We don’t specify \(L\) directly; instead we use a **length factor** over the straight line:

```gdscript
var straight = P1_2D.distance_to(P2_2D)
var L = straight + straight * length_factor
```

- `length_factor = 0.0` → length = straight line.  
- `length_factor = 0.1` → 10% longer, more sag, etc.

This “length constraint” is what makes it tricky: you can’t just plug in a random `a` and call it a day. You have to find a value of `a` that produces the correct length between \(P1_{2D}\) and \(P2_{2D}\).

---

## Solving for the parameters numerically

In our GDScript implementation, the function `_find_curve` does the heavy lifting.

The core idea:

1. Compute some convenient helper values from the endpoints and desired length \(L\).
2. Use a **simple numeric search** over a parameter `A` to satisfy a relationship between \(L\), the vertical difference \(dy\), the horizontal distance \(dx\) and `A`.
3. From that `A` derive `a`, `b`, and `c` for the final catenary formula.

Boiling down the key bits:

```gdscript
var dx = P2_2D.x - P1_2D.x
var dy = P2_2D.y - P1_2D.y
var L  = P1_2D.distance_to(P2_2D) + P1_2D.distance_to(P2_2D) * length_factor

# r is a helper value connected to the arc length
var r = sqrt(pow(L, 2) - pow(dy, 2)) / dx

# numeric search for A such that r * A ≈ sinh(A)
var left = r * A
var right = sinh(A)
while left >= right:
    left = r * A
    right = sinh(A)
    A = A + dA

A = A - dA   # step back one increment

# now derive a, b, c for y(x) = a*cosh((x-b)/a) + c
var a = dx / (2 * A)
var xb = (P2_2D.x + P1_2D.x) / 2
var b = xb - a * tanhi(dy / L)
var c = P1_2D.y - a * cosh((P1_2D.x - b) / a)
```

A few things worth highlighting:

- We’re **not** using an advanced root-finding method here; just a **linear scan** over `A` with small steps `dA`. That’s sufficient for our use case and easy to reason about.
- The condition `r * A ≈ sinh(A)` is the compact form of “the curve between P₁ and P₂ has length L”. Instead of re-deriving that in the code, we bake it into this numeric search.
- `tanhi` is a small helper implementing the inverse hyperbolic tangent:

  ```gdscript
  func tanhi(z: float) -> float:
      return 0.5 * log((1 + z) / (1 - z))
  ```

Once we have `(a, b, c)`, we can generate as many points as we want along the catenary:

```gdscript
var curve = []
var x = P1_2D.x
while x < P2_2D.x:
    var y = a * cosh((x - b) / a) + c
    # ... map back to 3D here ...
    x += line_step_size
```

---

## Mapping the 2D curve back into 3D

Remember `V1` and `V2` from above:

```gdscript
var V1 = Vector3(_P1.x, 0, _P1.z)
var V2 = _P2 - _P1
V2.y = 0   # purely horizontal
```

`V2.length()` is the same as `P2_2D.x`. So for a given x (between 0 and `P2_2D.x`) we can position the point along the 3D line from P₁ to P₂:

```gdscript
var xz: Vector3 = V1 + x / V2.length() * V2
curve.append(Vector3(xz.x, y, xz.z))
```

This means:

- The **horizontal projection** of the curve lies exactly between the two poles.
- The **vertical position** is taken from our 2D catenary’s `y`.

At the very end, we add a point *exactly* at P₂, because the step size may not hit that position perfectly:

```gdscript
y = a * cosh((P2_2D.x - b) / a) + c
var xz: Vector3 = V1 + P2_2D.x / V2.length() * V2 
curve.append(Vector3(xz.x, y, xz.z))
```

The result is a 3D `Array[Vector3]` with evenly spaced sample points along the hanging wire.

---

## Avoiding unnecessary recomputation: caching

In practice, many cables in the scene share the same geometry but are just **translated** (e.g. same distance and height difference between poles, just shifted in the world).

To exploit that, we use a small cache structure:

```gdscript
class CatenaryCache:
    var curve: Array
    var prev_P1: Vector3
    var prev_P2: Vector3
```

In `find_connection_points` we:

1. Check if we already have a curve for a pair of endpoints with the same relative offset (`P2 - P1`).
2. If so, we reuse the stored curve and just add the **offset** between old P₁ and new P₁:

   ```gdscript
   var offset = P1 - cache.prev_P1
   for i in range(cache.curve.size()):
       cache.curve[i] = cache.curve[i] + offset
   ```

3. If not, we compute a new catenary and append it to the cache.

That keeps things snappy when lots of similar connections are present.

---

## Putting it to use in LandscapeLab

From the engine’s point of view, an `AbstractConnection` subclass just needs to:

- Take two 3D points (connector docks on the poles),
- Calculate a set of intermediate points,
- Feed them into a `Curve3D` or similar geometry structure.

Our `CatenaryConnection` script does exactly that: it hides the numeric details behind a clean call:

```gdscript
connection_cache = connection.find_connection_points(P1, P2, 0.0013, [])
connection.apply_connection()
```

The renderer and feature layer composition decide **where** wires should appear. The catenary code decides **how** they hang in space given length and endpoints.

---

## Why this matters

Visually, it’s “just” a nicer wire between two poles.

But the underlying idea is powerful:

- We **respect physical constraints** (fixed cable length).
- We keep the **math isolated** in 2D and only then map back to 3D.
- We use a **simple numeric scheme** that’s robust and easy to reason about in production code.

For LandscapeLab, this means we can represent real-world infrastructure—like power lines, ropeways, hanging bridges—in a way that isn’t just pretty, but also structurally plausible. And the same pattern (project to 2D → solve → lift back to 3D) shows up over and over when we try to bring more “real physics” into our virtual landscapes.
